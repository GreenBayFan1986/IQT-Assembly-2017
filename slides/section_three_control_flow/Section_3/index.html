<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Assembly</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="control-flow">Control Flow</h1></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Understand and utilize status flags and conditional control flow</li><li>Understand and utilize x86(_64) string instructions and corresponding instruction prefixes</li><li>Understand and implement methods utilizing a variety of calling conventions (both x86 and x86_64)</li></ul></div><div class="step step-level-1 split-table" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="flags">FLAGS</h1><ul><li>A register that contains a variety of bits representing state and status information</li><li>Varies in size, but many portions (in newer processors) aren't used</li></ul><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>FLAGS</p></td><td><p>16 bits</p></td></tr><tr><td><p>EFLAGS</p></td><td><p>32 bits</p></td></tr><tr><td><p>RFLAGS</p></td><td><p>64 bits</p></td></tr></tbody></table></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="flag-layout">Flag Layout</h1><img src="images/eflags-intel2.jpg"></img><p>Credit: the Intel Manual</p></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="flags-we-care-about-now">Flags we care about now</h1><ul><li>Zero Flag (ZF) - set when an operation that sets the zero flag produces a zero - includes arithmetic and bitshift operations</li><li><dl><dt>Carry Flag (CF) - set when an arithmetic borrow or carry occurs during add/sub - e.g., the result of an add would have set bit 33 (in x86), or bit 65 (in x86_64)</dt><dd><ul><li>also set with some bitshift operations (such as when a bit falls off the end in a shl/shr)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="flags-we-care-about-now-cont-d">Flags we care about now (cont'd)</h1><ul><li><dl><dt>Overflow Flag (OF) - Indicates that sign bit of the result of an operation is different than the sign bits of the operands</dt><dd><ul><li>Ex.: Adding two large position numbers ends up producing a negative result (due to overflow)</li></ul></dd></dl></li><li>Sign Flag (SF) - Set to indicate the result of an operation is negative</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="accessing-the-flags">Accessing the Flags</h1><ul><li><dl><dt>Can be set and checked manually</dt><dd><ul><li>Some have special instructions for set and clear (which we'll talk about later)</li><li>Flag register can be accessed and set via pushf(d|q)/popf(d|q)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="pushf-and-popf">pushf and popf</h1><h2 id="description">Description</h2><p>Pushes the flags register (or the first 16 bits... eflags (32 bits) or rflags (64 bits) if pushfd or pushfq) onto the stack, and pops the value on top of the stack into the flags register (or eflags/rflags)</p><h2 id="basic-use">Basic Use</h2><pre class="highlight code nasm"><span class="nf">pushf</span>   <span class="c1">; flags have been pushed to the stack</span>
<span class="c1">; ... do stuff</span>
<span class="nf">popf</span>    <span class="c1">; flags have been restored!</span></pre></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="lab-6">Lab 6</h1><p>Flag manipulation...</p><ul><li>Copy the Lab6 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab6 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab6 $ ./lab6</pre></div><div class="step step-level-1" step="9" data-x="15300" data-y="0" data-rotate-z="90" data-rotate-x="0" data-rotate-y="0" data-scale="1" data-z="0"><h1 id="id1">Control Flow</h1></div><div class="step step-level-1" step="10" data-x="15300" data-y="2000" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="line-labels">Line Labels</h1><ul><li>Global and local</li></ul><pre class="highlight code nasm"><span class="nl">global_label:</span>
        <span class="c1">; stuff</span>

<span class="nl">.local_label:</span>
        <span class="c1">; more stuff</span></pre></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="15300" data-y="4000" data-z="0"><h1 id="everybody-jmp-around">Everybody jmp .around</h1><ul><li>jmp provides an unconditional branch, or transfer of execution to the target</li></ul><pre class="highlight code nasm"><span class="nl">.label1:</span>
    <span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
    <span class="nf">inc</span> <span class="nb">rax</span>
    <span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nb">rax</span>
    <span class="nf">jmp</span> <span class="nv">.label2</span>
    <span class="nf">mov</span> <span class="nb">rsp</span><span class="p">,</span> <span class="nb">rax</span>   <span class="c1">; never gets executed</span>
<span class="nl">.label2:</span>
    <span class="nf">shl</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">3</span>  <span class="c1">; execution continues here...</span>
    <span class="nf">xchg</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nb">rax</span>
    <span class="nf">ret</span></pre></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="15300" data-y="6000" data-z="0"><h1 id="call-and-ret">call and ret</h1><ul><li>Similar to jmp, but with a few key differences</li><li>Functionally equivalent to: push rip followed by a jmp X</li><li>Typically indicates a function call</li></ul><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">call</span> <span class="nv">label1</span> <span class="c1">; push RIP, jump to label1</span>
<span class="nf">jmp</span> <span class="nv">label2</span>
<span class="nl">label1:</span>
    <span class="nf">ror</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">ret</span>     <span class="c1">; returns control returns to "jmp label2"</span>
<span class="nl">label2:</span>
    <span class="c1">; ...</span></pre></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="15300" data-y="8000" data-z="0"><h1 id="more-on-ret">More on ret</h1><ul><li>Pops the return pointer off the stack and jumps to it</li><li>Used to return to the last point of execution (as shown on the previous slide)</li></ul><p>The stack, during function execution:</p><img src="images/section_3_call_ret_pt1.jpg"></img></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="15300" data-y="10000" data-z="0"><p>Once we get to the end, and we're ready to return:</p><pre class="highlight code nasm"><span class="c1">; ...</span>
<span class="nf">pop</span> <span class="nb">rbp</span>
<span class="nf">ret</span></pre><p>Our stack frame does something like this:</p><img src="images/section_3_call_ret_pt2.jpg"></img><p>popping off the old RBP, then popping the return pointer, and jumping to it (effectively "pop rip")</p></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="15300" data-y="12000" data-z="0"><h1 id="a-side-note-about-functions">A Side Note About Functions</h1><ul><li>Typically store the stack pointer ((E|R)SP) at the top of the function</li><li><dl><dt>If stored, must be (re)stored before returning</dt><dd><ul><li>If we don't, our stack location will be off</li><li>If left at the top of the stack, we will return ONTO the stack!</li></ul></dd></dl></li><li>This is not always done, as in FPO (Frame Pointer Optimization/Omission)</li><li>Functions will be covered in more depth later</li></ul><pre class="highlight code nasm"><span class="nl">myfunc:</span>
    <span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>
    <span class="nf">push</span> <span class="nb">rbp</span>
    <span class="c1">; ...</span>
    <span class="nf">pop</span> <span class="nb">rbp</span>
    <span class="nf">ret</span></pre></div><div class="step step-level-1" step="16" data-x="15300" data-y="13000" data-rotate-z="180" data-rotate-x="0" data-rotate-y="0" data-scale="1" data-z="0"><h1 id="conditional-control-flow-comparisons">Conditional Control Flow: Comparisons</h1></div><div class="step step-level-1" step="17" data-x="12800" data-y="13000" data-z="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1"><h1 id="cmp">cmp</h1><ul><li>Compares two values by subtraction (e.g., SUB op1, op2)</li><li>Sets flags to indicate whether the values were equal, or if one was larger</li><li>Flags set by this instruction: CF, OF, SF, ZF, AF, and PF</li></ul><p>Example:</p><pre class="highlight code nasm"><span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nf">cmp</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">0</span>  <span class="c1">; they're equal! the ZF is now set</span></pre></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="10300" data-y="13000" data-z="0"><h1 id="test">test</h1><ul><li>Compares two values by doing a bitwise AND</li><li>The SF, PF, and ZF get set by this operation</li><li>Often used to test whether or not a register is 0</li></ul><p>Example:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">test</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span> <span class="c1">; the ZF is set to 0, as the result isn't 0</span>

<span class="c1">; ...</span>

<span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nf">test</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span> <span class="c1">; the ZF is now 1</span></pre></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="7800" data-y="13000" data-z="0"><h1 id="jcc">Jcc</h1><ul><li>A large set of conditional branch instructions</li><li>Most execute based on the value of one or more flags</li><li><dl><dt>Some common conditional jumps:</dt><dd><ul><li>je or jz - Jump if Equal (or Jump if Zero)</li><li>jne/jnz - Jump if Not Equal (or Not Zero)</li><li>ja - Jump if Above (if the operand compared previously is greater)</li><li>jb/jc - Jump if Below (or Jump if Carry)</li></ul></dd></dl></li><li>Many others - Refer to the intel manual for a comprehensive list</li></ul><div class="notes"><p>A large number of the Jcc instructions actually evaluate to the same thing (e.g., JE vs JZ)</p></div></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="5300" data-y="13000" data-z="0"><h1 id="jcc-cont-d">Jcc Cont'd</h1><p>A simple check to see if the result of an operation is 0:</p><pre class="highlight code nasm"><span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nf">test</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="c1">; Because the zero flag is set here, we jump to the end</span>
<span class="nf">jz</span> <span class="nv">.end</span>
<span class="nf">mov</span> <span class="nb">rsi</span><span class="p">,</span> <span class="nb">rax</span>  <span class="c1">; not executed</span>
<span class="c1">; ...</span>
<span class="nl">.end:</span>
<span class="nf">ret</span></pre></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="2800" data-y="13000" data-z="0"><h1 id="id2">Jcc Cont'd</h1><p>A simple loop:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">10</span>    <span class="c1">; set our loop count to 10</span>
<span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>   <span class="c1">; set rax to 0</span>
<span class="c1">; This evaluates to: 10 + 9 + 8 + ... + 1 + 0</span>
<span class="nl">.continue:</span>
    <span class="nf">add</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span>  <span class="c1">; add the current value of rcx to rax</span>
    <span class="nf">dec</span> <span class="nb">rcx</span>       <span class="c1">; subtract 1 from rcx</span>
    <span class="nf">test</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nb">rcx</span> <span class="c1">; check to see if rcx is 0</span>
    <span class="nf">jnz</span> <span class="nv">.continue</span> <span class="c1">; jump back to .continue, if rcx isn't 0</span>

<span class="nf">ret</span></pre></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="300" data-y="13000" data-z="0"><h1 id="loop">loop</h1><ul><li>A simple macro for dec rcx/test rcx,rcx/jnz &lt;target&gt;</li><li>Expects ECX/RCX to be populated with a counter variable</li></ul><p>The loop from the previous slide could be re-written</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">10</span>
<span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nl">.continue:</span>
    <span class="nf">add</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span>
    <span class="nf">loop</span> <span class="nv">.continue</span>
<span class="nf">ret</span></pre></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="13000" data-z="0"><h1 id="lab-7">Lab 7</h1><p>Execution control flow...</p><ul><li>Copy the Lab7 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab7 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab7 $ ./lab7</pre></div><div class="step step-level-1" step="24" data-x="-2200" data-y="13000" data-rotate-x="90" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-z="0"><h1 id="string-instructions">String Instructions</h1><ul><li><dl><dt>What a "string" means to x86(_64)</dt><dd><ul><li>Really just a string of bytes</li><li>No particular qualms about terminators (e.g., '0')</li></ul></dd></dl></li><li>Several prefixes and a flag that will modify behavior (more on those later)</li><li>All of them have the unit to move/copy/initialize/scan appended to the end (e.g., scasb vs scasw vs scasd, etc)</li></ul></div><div class="step step-level-1" step="25" data-x="-2200" data-z="2500" data-rotate-x="90" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-y="13000"><h1 id="string-instructions-cont-d">String Instructions - Cont'd</h1><ul><li><dl><dt>Common features:</dt><dd><ul><li>RSI (or ESI, in x86) is treated as a pointer to the beginning of the "source"</li><li>RDI (or EDI, in x86) is treated as a pointer to the beginning of the "destination"</li><li>RCX (or ECX, in x86) is assumed to hold the count, if needed</li><li>RAX (or EAX, in x86) is assumed to hold the value to evaluate, if needed (e.g., store, compare against, etc)</li><li>Typically increments source and/or destination register pointers by the amount of data operated on (e.g., movsb would add 1 to both RSI and RDI, where movsd would add 4)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="26" data-rotate-x="90" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="13000" data-z="5000"><h1 id="some-common-instructions">Some Common Instructions</h1><ul><li>Scan String - scas(b/w/d/q) - Scans a string located as RDI for the value found in RAX/EAX/AX/AL (depending on size used), and increments the pointer</li><li>Store String - stos(b/w/d/q) - Initializes the string located at RDI to the value pointer at by RAX/EAX/AX/AL (depending on size used) and increments the pointer</li><li>Load String - lods(b/w/d/q) - Copies the value from RSI into RAX/EAX/AX/AL, and increments the pointer</li><li>Move String - movs(b/w/d/q) - Copies data from RSI into RDI, and increments both pointers.</li><li>Compare String - cmps(b/w/d/q) - Compares the values stored at RSI and RDI, and increments the pointer, updating the RFLAGS (or EFLAGS) register with the result.</li></ul></div><div class="step step-level-1" step="27" data-rotate-x="90" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="13000" data-z="7500"><h1 id="prefixes">Prefixes</h1><ul><li>Several instruction prefixes available to modify behavior - looping the instruction over a section of memory</li><li>All of them tend to use RCX/ECX/etc as a termination condition - decrementing each execution</li><li><dl><dt>Some prefixes available:</dt><dd><ul><li>REP - continue performing the action RCX times.</li><li>REPNE - continue performing the action RCX times, or until the FLAGS register indicates the operands were equal.</li><li>REPE - Continue perform the action RCX times, or until the FLAGS register indicates the operands were not equal.</li></ul></dd></dl></li><li>Often used by compilers to essentially inline C string functions (such as strlen, memset, memcpy, etc)</li></ul></div><div class="step step-level-1" step="28" data-rotate-x="90" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="13000" data-z="10000"><h1 id="prefix-examples">Prefix Examples</h1><ul><li>Unconditional:</li></ul><pre class="highlight code nasm"><span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>    <span class="c1">; rax is now 0</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">20</span>     <span class="c1">; rcx now contains 20</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="nv">_my_string_buf</span>
<span class="nf">rep</span> <span class="nv">stosb</span>       <span class="c1">; Continue to store 0 till rcx</span>
                <span class="c1">; is 0</span></pre><ul><li>Conditional:</li></ul><pre class="highlight code nasm"><span class="nf">xor</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rax</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">20</span>
<span class="c1">; assume the buffer below contains a string</span>
<span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="nv">_my_populated_buf</span>
<span class="nf">repne</span> <span class="nv">scasb</span>     <span class="c1">; continue until we hit a NULL byte</span>
<span class="c1">; RCX now contains 20 - &lt;the number of bytes we checked&gt;</span>
<span class="c1">; ...</span></pre></div><div class="step step-level-1" step="29" data-rotate-x="90" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="13000" data-z="12500"><h1 id="the-direction-flag">The Direction Flag</h1><ul><li>Controls the direction buffers are traversed when using the REP* prefixes</li><li>If set during execution/an operation, ALWAYS clear after (or crashes will likely occur)</li></ul><pre class="highlight code nasm"><span class="nf">std</span>     <span class="c1">; the direction flag has been set</span>
<span class="c1">; do stuff here</span>
<span class="nf">cld</span>     <span class="c1">; clear the direction flag, continue operations</span></pre></div><div class="step step-level-1" step="30" data-rotate-x="90" data-rotate-y="0" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="13000" data-z="15000"><h1 id="lab-8">Lab 8</h1><p>String Operations</p><ul><li>Copy the Lab8 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab8 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab8 $ ./lab8</pre></div><div class="step step-level-1" step="31" data-x="-2200" data-y="13000" data-z="15000" data-rotate-y="90" data-rotate-x="90" data-rotate-z="180" data-scale="1"><h1 id="functions">Functions</h1></div><div class="step step-level-1" step="32" data-x="-2200" data-y="10500" data-z="15000" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1"><h1 id="calling-conventions-x86">Calling Conventions: x86</h1><ul><li><dl><dt>Microsoft - many calling conventions exist for x86</dt><dd><ul><li>Different implications for how arguments get passed</li><li>Different implications for stack cleanup after function returns</li><li>Name mangling is often used to differentiate</li></ul></dd></dl></li><li><dl><dt>System V x86 Calling Convention</dt><dd><ul><li><dl><dt>Most POSIX-compliant (and POSIX-like) platforms abide by this</dt><dd><ul><li>Such as Linux, Solaris, BSD, OSX, etc</li><li>Also called cdecl</li></ul></dd></dl></li></ul></dd></dl></li><li>Other Calling Conventions</li></ul><div class="notes"><p>Many others exist (such as safecall or pascal) on Windows alone
Only a few will be covered here (outside of passing mention)</p></div></div><div class="step step-level-1" step="33" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="8000" data-z="15000"><h1 id="microsoft-conventions-stdcall">Microsoft Conventions: stdcall</h1><ul><li>Indicated to compiler (from C) by __stdcall prefix</li><li>Arguments pushed on the stack (in order from right to left)</li><li>The function being called (the "callee") cleans up the space allocated</li><li>Name gets decorated with an appended "@X", where X is the number of bytes to allocate (num args * 4)</li></ul></div><div class="step step-level-1" step="34" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="5500" data-z="15000"><h1 id="stdcall-cont-d">stdcall - cont'd</h1><p>Standard call in action - Stack Cleanup:</p><pre class="highlight code nasm"><span class="c1">; Equiv: void __stdcall myfunc(int a, int b);</span>
<span class="nl">_myfunc@8:</span>
    <span class="c1">; do stuff</span>
    <span class="nf">ret</span> <span class="mi">8</span>   <span class="c1">; we've cleaned up 8 bytes</span>

<span class="c1">; Equiv: int __stdcall myfunc2(int a);</span>
<span class="nl">_myfunc2@4:</span>
    <span class="c1">; do stuff</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>
    <span class="nf">ret</span> <span class="mi">4</span> <span class="c1">; cleaned up four bytes</span></pre></div><div class="step step-level-1" step="35" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="3000" data-z="15000"><h1 id="id3">stdcall - cont'd</h1><p>Standard call in action - Accessing Parameters:</p><ul><li>If EBP hasn't been pushed to the stack:</li></ul><pre class="highlight code nasm"><span class="nl">_myfunc@8:</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="c1">; parameter 1-above the return pointer</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">esp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span> <span class="c1">; parameter 2-above param 1</span>
    <span class="c1">; do stuff</span>
    <span class="nf">ret</span> <span class="mi">8</span></pre><ul><li>Otherwise:</li></ul><pre class="highlight code nasm"><span class="nl">_myfunc@8:</span>
    <span class="nf">push</span> <span class="nb">ebp</span>
    <span class="nf">mov</span> <span class="nb">ebp</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>  <span class="c1">; above both the ret ptr and old ebp</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span> <span class="o">+</span> <span class="mi">12</span><span class="p">]</span>
    <span class="nf">pop</span> <span class="nb">ebp</span>
    <span class="nf">ret</span> <span class="mi">8</span></pre></div><div class="step step-level-1" step="36" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="500" data-z="15000"><h1 id="microsoft-conventions-cdecl">Microsoft Conventions: cdecl</h1><ul><li>This is also the System V calling convention (e.g., what most non-microsoft platforms use)</li><li>Paramters passed in the same fashion as in stdcall</li><li>Stack cleanup is different, the calling function (e.g., caller) is responsible for cleanup</li><li>No real name mangling, aside from a leading underscore "_"</li></ul></div><div class="step step-level-1" step="37" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-2000" data-z="15000"><h1 id="cdecl-cont-d">cdecl - cont'd</h1><p>Cdecl in action: Stack cleanup</p><pre class="highlight code nasm"><span class="c1">; callee</span>
<span class="nl">_myfunc:</span>
    <span class="nf">push</span> <span class="nb">ebp</span>
    <span class="nf">mov</span> <span class="nb">ebp</span><span class="p">,</span> <span class="nb">esp</span>
    <span class="c1">; do stuff</span>
    <span class="nf">pop</span> <span class="nb">ebp</span>
    <span class="nf">ret</span>

<span class="nl">_caller:</span>
    <span class="c1">; ...</span>
    <span class="nf">push</span> <span class="mi">2</span>  <span class="c1">; arg 2</span>
    <span class="nf">push</span> <span class="mi">1</span>  <span class="c1">; arg 1</span>
    <span class="nf">call</span> <span class="nv">_myfunc</span>
    <span class="nf">add</span> <span class="nb">esp</span><span class="p">,</span> <span class="mi">8</span>  <span class="c1">; clean up</span>
    <span class="c1">; ...</span></pre></div><div class="step step-level-1" step="38" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-4500" data-z="15000"><h1 id="microsft-conventions-fastcall">Microsft Conventions: fastcall</h1><ul><li>First two arguments (from left to right) passed via registers (ECX and EDX)</li><li>Remaining arguments pushed on the stack (right to left, as with cdecl and stdcall)</li><li>Cleanup is performed by callee (as with stdcall)</li><li>Name mangling is similar to stdcall, but an additional "@" is prepended (e.g., "_@myfunc@8")</li></ul></div><div class="step step-level-1" step="39" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-7000" data-z="15000"><h1 id="conventions-thiscall">Conventions: thiscall</h1><ul><li>"Special" convention used for C++ non-static member functions</li><li>Defines a method of passing the "this" pointer (which allows those functions access to a specific instance of a class)</li><li>Slightly different between Microsoft and System V</li><li>Microsoft: The "this" pointer is passed in ECX, other parameters work like stdcall</li><li>System V: Works like cdecl, but the "this" pointer is the first argument to the function</li><li>C++ name mangling is a more complex topic (and somewhat compiler dependent)</li></ul></div><div class="step step-level-1" step="40" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-9500" data-z="15000"><h1 id="x64-calling-conventions">x64 Calling Conventions</h1><ul><li>Only one convention for each (Mostly... there are still some oddballs like vectorcall, but we aren't going to dive into those)</li><li>thiscall on x64 (both conventions) passes the "this" pointer as an implicit first argument (as it does for System V x86)</li><li>Both conventions work similarly to __fastcall, passing arguments in registers (though the registers differ between platforms)</li></ul></div><div class="step step-level-1" step="41" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-12000" data-z="15000"><h1 id="microsoft-x64-calling-convention">Microsoft x64 Calling Convention</h1><ul><li>Uses 4 registers to pass the first 4 parameters (RCX, RDX, R8, and R9)</li><li>Floating point values are passed via SIMD registers (XMM0-3... we'll talk more about this later)</li><li>Remaining values are added to the stack</li><li>Caller's responsibility to clean up (as with __cdecl)</li></ul></div><div class="step step-level-1" step="42" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-14500" data-z="15000"><h1 id="shadow-space">Shadow Space</h1><ul><li>x64 Calling Conventions require stack allocation for passed variables</li><li>Intent is to allow function being called to immediately spill registers (if desired)</li><li>Windows ABI requires space to be allocated for 4 registers (regardless of function parameter count)</li><li><dl><dt>Additional arguments (beyond 4) are added via the stack</dt><dd><ul><li>BUT in the location they would normally occur at if all parameters were passed that way</li><li>Example: param 5 would begin at [rsp + 0x20]</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="43" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-17000" data-z="15000"><h1 id="id4">Microsoft x64 Calling Convention</h1><p>No parameters:</p><pre class="highlight code nasm"><span class="nl">callee:</span>
    <span class="c1">; ...</span>
    <span class="nf">ret</span>

<span class="nl">caller:</span>
    <span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mh">0x20</span>   <span class="c1">; 8 * 4 - for register spillage</span>
    <span class="nf">call</span> <span class="nv">callee</span>
    <span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mh">0x20</span>   <span class="c1">; cleanup</span></pre></div><div class="step step-level-1" step="44" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-19500" data-z="15000"><h1 id="id5">Microsoft x64 Calling Convention</h1><p>5 Or More Parameters</p><pre class="highlight code nasm"><span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mh">0x28</span>           <span class="c1">; space to store 5 params</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mh">0x41</span>           <span class="c1">; param 1 = A</span>
<span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mh">0x42</span>           <span class="c1">; param 2 = B</span>
<span class="nf">mov</span> <span class="nv">r8</span><span class="p">,</span> <span class="mh">0x43</span>            <span class="c1">; param 3 = C</span>
<span class="nf">mov</span> <span class="nv">r9</span><span class="p">,</span> <span class="mh">0x44</span>            <span class="c1">; param 4 = D</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">],</span> <span class="mh">0x45</span>  <span class="c1">; param 5 = E</span>
<span class="nf">call</span> <span class="nv">myfunc</span>
<span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mh">0x28</span>           <span class="c1">; cleanup</span></pre></div><div class="step step-level-1" step="45" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-22000" data-z="15000"><h1 id="id6">Microsoft x64 Calling Convention</h1><p>Some additional reading on Microsoft's x64 calling convention:</p><ul><li><a href="https://blogs.msdn.microsoft.com/oldnewthing/20040114-00/?p=41053/">https://blogs.msdn.microsoft.com/oldnewthing/20040114-00/?p=41053/</a></li></ul></div><div class="step step-level-1" step="46" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-24500" data-z="15000"><h1 id="system-v-x64-calling-convention">System V x64 Calling Convention</h1><ul><li>Similar to the Microsoft calling convention, but more values are passed via registers</li><li>The first 6 arguments are passed via register (RDI, RSI, RDX, RCX, R8, and R9)</li><li>Floating point arguments go in SIMD registers (XMM0-7)</li><li>Additional arguments are pushed onto the stack</li><li>Shadow space is not required, but stack must remain 16-byte aligned</li><li>Red zone optimization provides free stack space for leaf functions</li></ul></div><div class="step step-level-1" step="47" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-27000" data-z="15000"><h1 id="red-zone">Red Zone</h1><ul><li>Allows use of the next 128 bytes below RSP without modifying stack pointer</li><li><dl><dt>Further function calls WILL clobber space</dt><dd><ul><li>Because of this, Red Zone use is most suitable for leaf functions</li><li>Safe from interrupt handlers, etc.</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="48" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-29500" data-z="15000"><h1 id="system-v-x64-example">System V x64 Example</h1><p>Calling strlen</p><pre class="highlight code nasm"><span class="k">extern</span> <span class="nv">strlen</span>

<span class="c1">; ensure NULL termination!</span>
<span class="nf">mystring</span> <span class="nv">db</span> <span class="s">"this is a string"</span><span class="p">,</span> <span class="mh">0x00</span>

<span class="nl">call_strlen:</span>
    <span class="nf">mov</span> <span class="nb">rdi</span><span class="p">,</span> <span class="nv">mystring</span>
    <span class="nf">call</span> <span class="nv">strlen</span>
    <span class="nf">ret</span></pre></div><div class="step step-level-1" step="49" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-32000" data-z="15000"><h1 id="return-values">Return Values</h1><p>Typically, the value returned at the end of the function call will be stored in RAX (for x64), or EAX (for x86)</p></div><div class="step step-level-1" step="50" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-34500" data-z="15000"><h1 id="register-preservation-x86">Register Preservation - x86</h1><ul><li>Volatile: EAX, ECX, and EDX don't need to be saved during a function call</li><li>All others must be preserved.</li></ul></div><div class="step step-level-1" step="51" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-37000" data-z="15000"><h1 id="register-preservation-x64">Register Preservation - x64</h1><ul><li><dl><dt>Windows: Volatile Registers (don't need to be preserved by callee)</dt><dd><ul><li>RAX, RCX, RDX, R8, R9, R10, and R11</li><li>XMM0-3 and 5</li><li>All others need to be preserved</li></ul></dd></dl></li><li><dl><dt>System V</dt><dd><ul><li>Most registers are volatile (need to be preserved by caller if the values are to be retained)</li><li>Exception: RBP, RBX, and R12-15 are non-volatile (must be preserved)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="52" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-39500" data-z="15000"><h1 id="additional-links">Additional Links</h1><p>More information on both x64 calling conventions:</p><ul><li><a href="http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/">http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/</a></li></ul></div><div class="step step-level-1" step="53" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-42000" data-z="15000"><h1 id="lab-9">Lab 9</h1><p>Functions</p><ul><li>Copy the Lab9 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab9 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab9 $ ./lab9</pre></div><div class="step step-level-1" step="54" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-44500" data-z="15000"><h1 id="windows-functions-lab">Windows Functions Lab</h1><p>Functions - Calling Conventions (x86)</p><ul><li>Copy the WinFunctions folder to your Windows system</li><li>Copy the nasm binary to WinFunctions\ASM\nasm.exe</li><li>Edit WinLab.nasm under WinFunctions\ASM\ASM\WinLab.nasm</li><li>build via VS2015 (as normal), or via msbuild using the following command:</li></ul><pre class="highlight code">C:\..\WinFunctions\ASM&gt; "%VS140COMNTOOLS%vsvars32.bat"
C:\..\WinFunctions\ASM&gt; msbuild ASM.sln</pre></div><div class="step step-level-1" step="55" data-rotate-x="90" data-rotate-y="90" data-rotate-z="180" data-scale="1" data-x="-2200" data-y="-47000" data-z="15000"><h1 id="section-review">Section Review</h1><ul><li>Flags</li><li>Jumps</li><li>Call and ret</li><li><dl><dt>string instructions</dt><dd><ul><li>prefix</li></ul></dd></dl></li><li>Functions and calling conventions</li></ul></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>