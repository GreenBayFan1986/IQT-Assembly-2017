<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Assembly</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="basic-operations">Basic Operations</h1></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Utilize basic arithmetic and bit operations</li><li>Understand the difference between signed and unsigned values, from an assembly perspective</li><li>Understand the Two's Complement representation of signed numbers</li><li>Understand the Stack as it pertains to assembly programming, and implement functions that utilize it to load and store data</li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="arithmetic-operations">Arithmetic Operations</h1><p>Basic Math Operations</p></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="the-add-and-sub-instructions">The add and sub instructions</h1><h2 id="description">Description</h2><p>Adds and subtracts arbitrary values. The destination (where the result is stored) is the first value provided.</p><h2 id="basic-use">Basic Use</h2><p>We can use a combination of registers and immediates as operands:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">add</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">2</span> <span class="c1">; rax now contains 3</span>
<span class="nf">sub</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span> <span class="c1">; rax now contains 2</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">2</span>
<span class="nf">add</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span> <span class="c1">; as above, rax now contains 4</span>
<span class="nf">sub</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span> <span class="c1">; rax is now back to 2</span></pre></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="the-mul-instruction">The mul instruction</h1><h2 id="id1">Description</h2><p>Allow multiplication of arbitrary values. Takes a single argument, multiplies by rax/eax/ax (depending on operand size).</p><h2 id="id2">Basic Use</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">10</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="mi">10</span>
<span class="nf">mul</span> <span class="nb">ecx</span>         <span class="c1">; rax now contains 100</span>

<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">5</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">7</span>
<span class="nf">mul</span> <span class="nb">rcx</span>     <span class="c1">; rax now contains 35</span></pre><div class="notes"><p>Results are mostly stored in the source operand (ax/eax/rax), but may be stored in dx/edx/rdx as well if overflow occurs. The table on the next slide illustrates this.</p></div></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="the-mul-instruction-storing-results">The mul instruction: storing results</h1><p>Results are stored in the source (possible), or in a combination of registers in the configuration below:</p><img src="images/section_2_mul_table.jpg"></img></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="the-div-instruction">The div instruction</h1><h2 id="id3">Description</h2><p>As with mul, div takes a single argument, and divides the value stored in the dividend register(s) by it. This is typically ax/eax/rax (and the *dx equivalents), but may vary a bit depending on the size (chart provided on the next slide).</p><h2 id="id4">Basic Use</h2><pre class="highlight code nasm"><span class="c1">; clearing the register where the</span>
<span class="c1">; high bits would be stored, we're only using what's in rax!</span>
<span class="nf">mov</span> <span class="nb">rdx</span><span class="p">,</span> <span class="mi">0</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">10</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">2</span>
<span class="nf">div</span> <span class="nb">rcx</span>    <span class="c1">; rax now contains 5</span></pre></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="div-operation-results">div: operation results</h1><p>Where to retrieve the results of a div from depends on the size of the arguments. The table below illustrates this relationship:</p><img src="images/section_2_div_table.jpg"></img></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="inc-and-dec">inc and dec</h1><h2 id="id5">Description</h2><p>Adds or subtracts one from the provided register, storing the result in place.</p><h2 id="id6">Basic Use</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">; rax now contains 1</span>
<span class="nf">inc</span> <span class="nb">rax</span>         <span class="c1">; rax now contains 2</span>
<span class="nf">inc</span> <span class="nb">rax</span>         <span class="c1">; rax now contains 3</span>
<span class="nf">dec</span> <span class="nb">rax</span>         <span class="c1">; rax now contains 2</span></pre></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="lab-3">Lab 3</h1><p>Arithmetic Operations</p><ul><li>Copy the Lab3 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab3 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab3 $ ./lab3</pre></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="the-stack">The Stack</h1><ul><li>Grows from high memory to low memory</li><li>Current function typically exists within a stack "frame" (but not always!)</li></ul></div><div class="step step-level-1" step="11" data-x="16000" data-y="2000" data-rotate-y="0" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="stack-frames">Stack Frames</h1><ul><li>RSP (or ESP) points to the top of the stack</li><li>RBP (or EBP) points to the "base" of the stack frame</li></ul></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="16000" data-y="4000" data-z="0"><h1 id="stack-frame-layout">Stack Frame Layout</h1><img src="images/section_2_stack_diagram_1.jpg"></img></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="16000" data-y="6000" data-z="0"><h1 id="expanding-the-stack-frame">Expanding the Stack Frame</h1><ul><li>Can modify the value of RSP directly to allocate more stack space:</li></ul><pre class="highlight code nasm"><span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">16</span></pre><ul><li>But you must always ensure you clean up before the function returns:</li></ul><pre class="highlight code nasm"><span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">16</span></pre></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="16000" data-y="8000" data-z="0"><h1 id="stack-alignment">Stack Alignment</h1><ul><li>x86_64 expects 16 byte stack alignment</li><li>Allocating odd amounts of space can cause things to break</li><li>ALWAYS make sure you clean up your stack before returning</li></ul></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="16000" data-y="10000" data-z="0"><h1 id="gdb-stack-frames">GDB - Stack Frames</h1><ul><li>Examining the Call Stack (backtrace / bt)</li><li><dl><dt>Frames and information</dt><dd><ul><li>frame || f - Get information about the current frame</li><li>info args - Get information about function arguments</li><li>info locals - Information about local variables</li></ul></dd></dl></li></ul><div class="notes"><p>May be appropriate to demo GDB and stack frames</p></div></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="16000" data-y="12000" data-z="0"><h1 id="new-instructions-push-and-pop">New Instructions: push and pop</h1><h2 id="id7">Description</h2><p>Push will subtract a pointer-width amount of space from RSP, and place the argument in the newly-allocated location.
Pop performs the opposite action, storing the value just below RSP in the register provided, and adding a pointer-width amount to RSP.
For every push, you will need to pop!</p><h2 id="id8">Basic Use</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">; 1 is now stored in rax.</span>
<span class="nf">push</span> <span class="nb">rax</span>        <span class="c1">; 1 is now stored at the top of the stack</span>
<span class="nf">pop</span> <span class="nb">rcx</span>         <span class="c1">; rcx now contains 1</span></pre></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="16000" data-y="14000" data-z="0"><h1 id="growing-the-stack">Growing the Stack</h1><p>After a push operation:</p><img src="images/section_2_stack_diagram_2.jpg"></img></div><div class="step step-level-1" step="18" data-x="16000" data-y="14000" data-rotate-y="90" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="restoring-the-stack">Restoring the Stack</h1><p>After a pop operation:</p><img src="images/section_2_stack_diagram_3.jpg"></img></div><div class="step step-level-1" step="19" data-y="16000" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="16000" data-z="0"><h1 id="lab-4">Lab 4</h1><p>Stack Operations</p><ul><li>Copy the Lab4 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab4 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab4 $ ./lab4</pre></div><div class="step step-level-1" step="20" data-rotate-y="0" data-y="16100" data-x="15000" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="negative-numbers">Negative Numbers</h1><h2 id="two-s-complement">Two's Complement</h2><img src="images/section_2_counter.jpeg"></img><ul><li>Negative numbers on the x86(_64) platform are represented via Two's Complement</li></ul><div class="notes"><p>On understanding Two's Complement: think of what happens when a mechanical counter (like the one pictured on the slide) counts down to zero,
and rolls over. You might see it flip all the numbers over: e.g., 9999</p></div></div><div class="step step-level-1" step="21" data-y="18600" data-z="0" data-x="15000" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1"><h1 id="id9">Two's Complement</h1><ul><li>Invert the bits of the number (in binary), and add one!</li></ul><img src="images/section_2_twos_complement_p1.jpg"></img></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="15000" data-y="21100" data-z="0"><h1 id="two-s-complement-cont-d">Two's Complement (cont'd)</h1><ul><li>Simplifies addition operations</li><li>Unified Add/Sub</li></ul><p>Example: Adding 2 and -1</p><pre class="highlight code">Carry Row:  11
            1111
          + 0010
            ----
            0001</pre></div><div class="step step-level-1" step="23" data-x="17000" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-y="23600" data-z="0"><h1 id="sub-registers-and-sign-extending">Sub Registers and Sign extending</h1><ul><li>When copying smaller data into a register, sign extending may be used (rather than zero extending)</li><li>Sign extending preserves the "signed" attributes of the data being copied.</li><li>The movsx instruction (just like movzx) handles this.</li></ul></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="19000" data-y="26100" data-z="0"><h1 id="the-movsx-instruction">The movsx Instruction</h1><h2 id="id10">Description</h2><p>Much like movzx, movsx can be used to move data into a portion of a larger register, while preserving its sign.</p><h2 id="id11">Basic Use</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">cl</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
<span class="nf">movsx</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">cl</span>   <span class="c1">; rax now contains -1.</span></pre></div><div class="step step-level-1" step="25" data-y="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="21000" data-z="0"><h1 id="bitwise-operations">Bitwise Operations</h1></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="23000" data-y="0" data-z="0"><h1 id="bit-shifting">Bit shifting</h1><ul><li>Two unsigned shift operations exist: shl (shift left) and shr (shift right)</li><li>Shifting moves the bits in the register over the direction (left or right) and number of bits specified</li><li>Bits that fall off the end (and overflow) will disappear, except for the last one, which ends up in the
carry flag (which we'll discuss later)</li><li>The extra space created gets padded with 0's</li></ul></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="25000" data-y="0" data-z="0"><h1 id="left-shift-diagram">Left Shift Diagram</h1><p>The following snippet of assembly:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">shl</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">shl</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">3</span></pre><p>Can be modelled by the following table:</p><img src="images/section_2_bitops_shl_1.jpg"></img></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="27000" data-y="0" data-z="0"><h1 id="right-shift-diagram">Right Shift Diagram</h1><p>Similarly, the following snippet of assembly:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">32</span>
<span class="nf">shr</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">shr</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">4</span></pre><p>Can be modelled by the following table:</p><img src="images/section_2_bitops_shr_1.jpg"></img></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="29000" data-y="0" data-z="0"><h1 id="binary-and-or">Binary and/or</h1><ul><li>and can be used to determine whether or not one or more bits are set in</li><li>or will tell you if the bit is set in at least one place</li><li>Both take two operands, one of which will hold the result after the operation completes</li></ul><h2 id="use">Use:</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>              <span class="c1">; rax contains 00000001</span>
<span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">5</span>              <span class="c1">; rcx contains 00000101</span>

<span class="nf">and</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span>    <span class="c1">; rax contains 00000001</span>
<span class="nf">or</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span>             <span class="c1">; rax contains 00000101</span></pre><div class="notes"><p>Another way to think about this (if familiar with sets and set theory): AND gives us the intersection between the two sets of bits, OR gives us their union.</p></div></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="31000" data-y="0" data-z="0"><h1 id="and-table">And Table</h1><img src="images/section_2_bitops_and.jpg"></img></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="33000" data-y="0" data-z="0"><h1 id="or-table">Or Table</h1><img src="images/section_2_bitops_or.jpg"></img></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="35000" data-y="0" data-z="0"><h1 id="binary-not">Binary not</h1><ul><li>Inverts the bits in a given register</li></ul><p>Example:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">0</span>      <span class="c1">; rax now contains 00000000</span>
<span class="nf">not</span> <span class="nb">rax</span>         <span class="c1">; rax is now all 1's (or 0xffffffff)</span></pre><p>Similarly:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">; rcx now contains 1</span>
<span class="nf">not</span> <span class="nb">rcx</span>         <span class="c1">; rcx now contains:</span>
                <span class="c1">; 0xfffffffe (all 1's minus the first bit)</span></pre></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="37000" data-y="0" data-z="0"><h1 id="properties-of-exclusive-or">Properties of eXclusive Or</h1><ul><li>XOR yields 1 only if the bit is set in either the source or destination, but NOT both</li><li>Any value XOR'd with itself is 0.</li><li>0 XOR'd with any value is that value</li><li>For numbers A, B, and C, if A ^ B = C, then C ^ A = B
and C ^ B = A.</li></ul></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="39000" data-y="0" data-z="0"><h1 id="xor-table">XOR table</h1><img src="images/section_2_bitops_xor.jpg"></img></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="41000" data-y="0" data-z="0"><h1 id="rotating-bits">Rotating Bits</h1><ul><li>The values in the register are rotated the indicated number of places to the right or left</li><li>Bits that are rotated off the end of the register and moved back to the beginning</li></ul><p>Instruction:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">; rax contains 1 (00000001)</span>
<span class="nf">rol</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>  <span class="c1">; rax now contains 2 (00000010)</span>
<span class="nf">ror</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">; rax now contains 1 (00000001)</span>
<span class="nf">ror</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">; rax now looks like: (10000000)</span></pre></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="43000" data-y="0" data-z="0"><h1 id="signed-bit-operations">Signed Bit Operations</h1><ul><li>Shift operations that are sign aware exist (SAR for right and SAL for left)</li><li>Work in the same fashion as shr/shl, except for how bits shifted off the end are treated (bits still disappear, but the sign of the resulting value is retained)</li></ul></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="45000" data-y="0" data-z="0"><h1 id="lab-5">Lab 5</h1><p>Bit operations</p><ul><li>Copy the Lab5 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab5 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab5 $ ./lab5</pre></div><div class="step step-level-1" step="38" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="47000" data-y="0" data-z="0"><h1 id="section-review">Section Review</h1><ul><li>Arithmetic Operations</li><li><dl><dt>The Stack</dt><dd><ul><li>Stack Frames</li><li>Stack Alignment</li></ul></dd></dl></li><li>Signed Values and Two's Complement</li><li>Bit Operations</li></ul></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>