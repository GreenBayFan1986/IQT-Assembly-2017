<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Assembly</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="introduction-to-assembly-programming">Introduction to Assembly Programming</h1><pre class="highlight code nasm"><span class="nf">instructor</span>      <span class="nv">db</span> <span class="s">"Jeremy Cantu"</span><span class="p">,</span> <span class="mh">0x0a</span><span class="p">,</span> <span class="mh">0x00</span>
<span class="nf">email</span>  <span class="nv">db</span> <span class="s">"jcantu@silotechgroup.com"</span><span class="p">,</span> <span class="mh">0x0a</span><span class="p">,</span> <span class="mh">0x00</span></pre></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="course-roadmap">Course Roadmap</h1><pre class="highlight code nasm"><span class="nl">content:</span>
        <span class="nf">jmp</span> <span class="nv">.introduction</span>

<span class="nl">.introduction:</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="nv">HowToAsm</span>
        <span class="nf">jmp</span> <span class="nv">.basic_operations</span>

<span class="nl">.basic_operations:</span>
        <span class="nf">call</span> <span class="nv">.arithmetic</span>
        <span class="nf">call</span> <span class="nv">.bit_operations</span>
        <span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nv">DataTypes</span>
        <span class="nf">jmp</span> <span class="nv">.control_flow</span>

<span class="nl">.control_flow:</span>
        <span class="nf">jmp</span> <span class="nv">.hardware_essentials</span>

<span class="nl">.hardware_essentials:</span>
        <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="nv">Memory</span>
        <span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nv">Interrupts</span>
        <span class="nf">call</span> <span class="nv">FloatingPoint</span>
        <span class="nf">call</span> <span class="nb">Si</span><span class="nv">md</span>
        <span class="nf">call</span> <span class="nv">.systems_programming</span>

<span class="nl">.systems_programming:</span>
        <span class="nf">ret</span></pre></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="assembly-an-introduction">Assembly: An Introduction</h1></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Understand the relationship between assembly language and opcodes</li><li>Understand byte ordering, as it pertains to Assembly Programming</li><li>Identify x86(_64) General Purpose Registers</li><li>Perform basic memory access operations</li><li>Begin debugging with the GNU Source-Level Debugger (GDB)</li><li>Understand basic data sizes and types with regard to x86(_64)</li></ul></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="understanding-assembly">Understanding Assembly</h1><ul><li><dl><dt>What is Assembly?</dt><dd><ul><li>Provides "instructions" (human-friendly) that map to "opcodes" (processor-friendly)</li><li>Typically very hardware-specific</li></ul></dd></dl></li><li><dl><dt>Why use assembly?</dt><dd><ul><li>Performance</li><li>Utilize otherwise unexposed hardware features</li><li>Some operations can't easily be expressed in higher level languages (such as C)</li></ul></dd></dl></li></ul><div class="notes"><p>Performance is now much less often a reason to use assembly than it was in the past (as compilers have steadily improved, and more features exposed via intrinsics).</p></div></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="assembly-instructions">Assembly Instructions</h1><ul><li>Typically consist of an instruction of some kind, and some operands</li><li><dl><dt>Operands can consist of several things, to include:</dt><dd><ul><li>Registers</li><li>Memory Addresses</li><li>Immediate (literal) Values</li></ul></dd></dl></li><li>Other data types and some prefixes (which modify what the instruction does) also exist</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="opcodes">Opcodes</h1><ul><li>One or more bytes that the processor decodes (and executes)</li><li>Typically direct translations from assembly language instructions</li><li>x86 and x86_64 instructions are variable length</li><li>Syntax is (slightly) complicated</li></ul></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="id1">Assembly Instructions</h1><p>This set of instructions:</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">0x01</span>
<span class="nf">ret</span></pre><p>Becomes...</p><div class="notes"><p>Thus, this set of instructions becomes the follow set of opcodes.</p></div></div><div class="step step-level-1" step="8" data-x="11200" data-y="0" data-rotate-y="90" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="id2">Opcodes</h1><p>...This set of opcodes</p><pre class="highlight code objdump-nasm"><span class="x">0xb8 0x01 0x00 0x00 0x00
0xc3</span></pre><div class="notes"><p>Perform opcodes demo</p></div></div><div class="step step-level-1" step="9" data-x="11200" data-y="2000" data-rotate-y="0" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="assemblers-and-syntax">Assemblers and Syntax</h1><ul><li><dl><dt>A number of different options exist for assemblers</dt><dd><ul><li>GAS - the GNU Assembler</li><li>nasm/yasm - The Netwide Assembler/Yet another Assembler (a rewrite of NASM)</li><li>masm - the Microsoft assembler</li></ul></dd></dl></li><li>Most have special quirks and slight differences in how syntax is handled (though they are similar)</li><li>This course will focus on NASM, which uses Intel syntax</li></ul></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="11200" data-y="4000" data-z="0"><h1 id="syntax-differences-some-examples">Syntax Differences - Some Examples</h1><ul><li>Intel Syntax: Used by NASM/YASM and others</li></ul><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">0x01</span></pre><ul><li>AT&amp;T Syntax: Used by GAS and others</li></ul><pre class="highlight code gas"><span class="nf">movl</span> <span class="no">$0x01</span><span class="p">,</span> <span class="nv">%eax</span></pre><ul><li>Other flavors also exist</li></ul><div class="notes"><p>This is one very blatant example, but many other assemblers (MASM, etc) will have small quirks to how you type in your assembly instructions. All equate to (about) the same thing, however.</p></div></div><div class="step step-level-1" step="11" data-y="6000" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="11200" data-z="0"><h1 id="byte-ordering">Byte Ordering</h1><ul><li>Determines the order bytes appear in memory</li><li><dl><dt>Big Endian stores the most significant (or biggest) value first</dt><dd><ul><li>the memory address: 0x10203040 would appear as: 0x10 0x20 0x30 0x40</li></ul></dd></dl></li><li><dl><dt>Little Endian puts the least significant (or little) value first</dt><dd><ul><li>the memory address: 0x10203040 would appear as: 0x40 0x30 0x20 0x10</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="11200" data-y="8000" data-z="0"><h1 id="id3">Byte Ordering</h1><ul><li>x86(_64) is little Endian</li><li>Again, least significant byte (not bit) appears first</li></ul><p>In memory, this address:</p><pre class="highlight code">0xdeadbeef</pre></div><div class="step step-level-1" step="13" data-x="11200" data-y="8000" data-rotate-y="90" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-z="0"><h1 id="id4">Byte Ordering</h1><p>Becomes:</p><pre class="highlight code">0xefbeadde</pre></div><div class="step step-level-1 split-table" step="14" data-y="10000" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-z="0"><h1 id="id5">Byte Ordering</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Initial:</p></td><td><p>0xde</p></td><td><p>0xad</p></td><td><p>0xbe</p></td><td><p>0xef</p></td></tr><tr><td><p>Memory:</p></td><td><p>0xef</p></td><td><p>0xbe</p></td><td><p>0xad</p></td><td><p>0xde</p></td></tr></tbody></table></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="12000" data-z="0"><h1 id="memory-the-10-000-foot-view">Memory: The 10,000 Foot View</h1><ul><li>Various Memory Components take differing amounts of time to access</li><li>Most higher level languages (such as C) abstract this away, the developer is not really exposed to it</li><li>Assembly gives you a bit more control (though some things are still hidden on most modern platforms)</li></ul></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="14000" data-z="0"><h1 id="the-memory-hierarchy">The Memory Hierarchy</h1><p>From Fastest Access to Slowest:</p><ul><li>Registers</li><li>Cache (L1/L2/L3)</li><li>System Memory</li><li>Disk</li></ul></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="16000" data-z="0"><h1 id="virtual-memory">Virtual Memory</h1><ul><li>Hardware allows abstraction of memory addressing</li><li>Most addressing deals with virtual addresses, which are translated (via lookup table) to physical addresses</li><li>More than one "view" of a physical memory segment can exist (in different processes)</li><li>Each user mode process appears to have a full range of addressable memory and resources</li><li>Most modern OSes support paging, allowing us to pretend we have a much greater amount of physical memory than actually exists</li></ul><div class="notes"><p>We will discuss virtual memory and memory mappings in general later on, when we discuss specific hardware features</p></div></div><div class="step step-level-1 shrink-image block-image" step="18" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="18000" data-z="0"><h1 id="process-memory-layout">Process Memory Layout</h1><p>A Very High level view:</p><img src="./images/Process_Layout.svg"></img></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="20000" data-z="0"><h1 id="id6">Process Memory Layout</h1><ul><li>Stack Segments typically grown from high to low memory addresses</li><li><dl><dt>Modules in the previous diagram indicate executable files loaded into the process space; some examples include:</dt><dd><ul><li>glibc (more specifically, the .so containing the libc code)</li><li>kernel32.dll</li><li>Currently running executable</li></ul></dd></dl></li><li>Heap sections and Anonymous Mappings</li><li>Kernel memory</li><li>Other Items</li></ul></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="22000" data-z="0"><h1 id="registers">Registers</h1><ul><li>Assembly programming gives us total control over access to these</li><li>Special hardware structures on the processor</li><li>Some are general purpose (e.g., can store any type of data)</li><li>Others are specialized, and may contain status codes, flags, etc., or be associated with specific hardware</li><li>Limited in number</li></ul></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="24000" data-z="0"><h1 id="general-purpose-registers">General Purpose Registers</h1><ul><li>Shared registers have addressable subregisters</li><li>64 bit/32 bit/16 bit/8 bit</li><li>x86_64 contains many more general purpose registers than x86
(though they don't all have subregisters)</li></ul></div><div class="step step-level-1 register-table" step="22" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="26000" data-z="0"><h1 id="x86-and-x64-registers">x86 and x64 Registers</h1><img src="images/section_1_register_table.jpg"></img><ul><li>rbp/ebp - Base Pointer</li><li>rsp/esp - Stack Pointer</li></ul><div class="notes"><p>Being general purpose, most of the registers may be
used to store arbitrary values, though some may have defined
uses with certain instructions (which we'll discuss later on).
The registers listed at the bottom generally have some special uses
however, where RIP/EIP points at the current place in memory we are executing, and RSP/ESP typically points to the top of the stack (which will also be discussed in greater detail later on).</p></div></div><div class="step step-level-1" step="23" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="11200" data-y="28000" data-z="0"><h1 id="registers-cont-d">Registers (cont'd)</h1><ul><li>rip/eip - Instruction Pointer (Program Counter)</li><li>Additional x86_64 Registers: r8 - r15</li></ul></div><div class="step step-level-1" step="24" data-x="13200" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-y="30000" data-z="0"><h1 id="register-data-and-pointers">Register Data and Pointers</h1><ul><li>General Purpose Registers can contain up to pointer-sized amounts of data (4 bytes on 32 bit, 8 on 64)</li><li>They can also contain memory addresses (pointers) to blocks of data residing elsewhere in the process.</li><li>Addresses can be manipulated via addition, subtraction, multiplication, etc</li><li>Square brackets dereference (access the stuff stored AT the memory address)</li></ul><p>Example:</p><pre class="highlight code nasm"><span class="c1">; A register - we will be operating on whatever</span>
<span class="c1">; happens to be stored in it</span>
<span class="nf">rax</span>
<span class="c1">; We are attempting to access the stuff stored</span>
<span class="c1">; at the address in rax (dereference)</span>
<span class="err">[</span><span class="nf">rax</span><span class="p">]</span></pre></div><div class="step step-level-1" step="25" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="15200" data-y="32000" data-z="0"><h1 id="register-data-and-pointers-example">Register Data and Pointers - Example</h1><h2 id="first-we-ll-store-a-pointer-memory-address-in-rax-and-then-store-some-stuff-there">First, we'll store a pointer (memory address) in rax, and then store some stuff there:</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mh">0xc0ffee</span> <span class="c1">; a memory address (hopefully valid!)</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rax</span><span class="p">],</span> <span class="mi">100</span> <span class="c1">; now we store some data there!</span></pre><img src="images/section_1_pointers.jpg"></img></div><div class="step step-level-1" step="26" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="17200" data-y="34000" data-z="0"><h1 id="register-data-and-pointers-example-part-2">Register Data and Pointers - Example (Part 2)</h1><h2 id="now-we-ll-copy-that-address-into-rcx">Now, we'll copy that address into rcx:</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="nb">rax</span> <span class="c1">; now we copy the pointer!</span></pre><img src="images/section_1_pointers_second_stage.jpg"></img><ul><li>Now both point to the same place!</li></ul></div><div class="step step-level-1" step="27" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="19200" data-y="36000" data-z="0"><h1 id="register-data-and-pointers-example-part-3">Register Data and Pointers - Example (Part 3)</h1><h2 id="now-we-ll-access-the-data-stored-at-the-address-and-copy-it-into-rcx">Now, we'll access the data stored at the address, and copy it into rcx</h2><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">rcx</span><span class="p">,</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">]</span> <span class="c1">; copy the data from addr 0xc0ffee into rcx</span></pre><img src="images/section_1_pointers_third_stage.jpg"></img><p>Please note that this replaces the old value in rcx, which was just the address we're accessing.</p></div><div class="step step-level-1" step="28" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="21200" data-y="38000" data-z="0"><h1 id="now-for-our-first-instruction">Now, for our first instruction...</h1></div><div class="step step-level-1" step="29" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="23200" data-y="40000" data-z="0"><h1 id="nop">NOP</h1><ul><li>Does nothing! (Sort of)</li><li>Used for padding/alignment/timing reasons</li><li>Idempotent instruction (doesn't affect anything else in the system)</li><li>One-byte NOP translates to the opcode: 0x90</li></ul></div><div class="step step-level-1" step="30" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="25200" data-y="42000" data-z="0"><h1 id="debugging-assembly">Debugging Assembly</h1><ul><li>We will be using the GNU Project Debugger (GDB)</li><li><dl><dt>Command Line Debugger, provides a large set of features</dt><dd><ul><li>Natively supports Python scripting</li><li>Supports a large number of architectures (and even quite a few languages)</li><li>Provides a Text User Interface (TUI) mode</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="31" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="27200" data-y="44000" data-z="0"><h1 id="debugging-assembly-cont-d">Debugging Assembly (cont'd)</h1><ul><li>Setting breakpoints programmatically may be difficult at times</li><li>A good strategy may include applying breakpoints directly in your code for debugging purposes</li><li>Fortunately, an assembly instruction exists for doing just this:</li></ul><pre class="highlight code nasm"><span class="nf">int3</span> <span class="c1">; NOTE: no space between int and 3</span></pre><p>Which translates to the following opcode:</p><pre class="highlight code objdump-nasm"><span class="x">0xcc</span></pre><div class="notes"><p>Tips for debugging assembly: keep an eye on registers, use breakpoints liberally!</p></div></div><div class="step step-level-1" step="32" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="29200" data-y="46000" data-z="0"><h1 id="debugging-with-gdb">Debugging With GDB</h1><p>Preconfiguration:</p><ul><li>.gdbinit provides a way to run a number of setup commands on launch</li><li>Simply copy the config file to your home directory:</li></ul><pre class="highlight code bash">~/Desktop/handouts $ cp sample-gdbinit ~/.gdbinit</pre><p>Launching a program with GDB:</p><pre class="highlight code bash">~/Desktop/Lab1 $ gdb lab1
<span class="o">(</span>gdb<span class="o">)</span> run
...
<span class="o">(</span>gdb<span class="o">)</span> quit</pre></div><div class="step step-level-1" step="33" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="31200" data-y="48000" data-z="0"><h1 id="gdb">GDB</h1><ul><li><dl><dt>Basic Use: Generally useful commands</dt><dd><ul><li>info - Displays information (in general, or about specific commands)</li><li>help - Can provide context-specific help; e.g., listing available commands/options</li></ul></dd></dl></li><li>refresh:  will redraw the console window</li></ul></div><div class="step step-level-1" step="34" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="33200" data-y="50000" data-z="0"><h1 id="id7">GDB</h1><ul><li><dl><dt>Single Stepping (step/s)</dt><dd><ul><li>Can also use stepi</li></ul></dd></dl></li><li><dl><dt>Stepping Over (next/n)</dt><dd><ul><li>Can also use nexti</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="35" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="35200" data-y="52000" data-z="0"><h1 id="id8">GDB</h1><ul><li><dl><dt>Breakpoints (break)</dt><dd><ul><li>Allows us to programmatically set breakpoints without modifying application source code</li></ul></dd></dl></li><li>info break - shows us information about all currently set breakpoints</li><li>Removing breakpoints (clear and delete)</li></ul><p>Example:</p><pre class="highlight code bash"><span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break</span> myfunc
Breakpoint <span class="m">1</span> at 0x4004a4
<span class="o">(</span>gdb<span class="o">)</span> info <span class="nb">break</span>
Num     Type             Disp Enb Address
<span class="m">1</span>               breakpoint   keep y   0x00000000004004a4
<span class="o">(</span>gdb<span class="o">)</span> delete 1
<span class="o">(</span>gdb<span class="o">)</span> info <span class="nb">break</span>
No breakpoints or watchpoints</pre><div class="notes"><p>Demo stepping and using GDB with a sample init file and our opcodes demo</p></div></div><div class="step step-level-1" step="36" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="37200" data-y="54000" data-z="0"><h1 id="memory-access-instructions">Memory Access Instructions</h1><ul><li>We'll begin looking at instructions to copy and access data from various locations in memory</li><li>Additionally, we will begin examining address calculation</li></ul></div><div class="step step-level-1" step="37" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="39200" data-y="56000" data-z="0"><h1 id="memory-access-mov">Memory Access - mov</h1><h2 id="description">Description</h2><p>Moves a small block of memory from a source (the right-hand operand) to destination (the left operand). An amount of data may be specified (more on this later).</p><h2 id="basic-use">Basic Use</h2><pre class="highlight code nasm">    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mh">0x01</span>      <span class="c1">; immediate - rax is now 1</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span>       <span class="c1">; register - rax now has a copy of rcx</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rbx</span><span class="p">]</span>     <span class="c1">; memory - rbx is treated as a pointer</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rbx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span> <span class="c1">; copying a quad word (8 bytes)</span></pre><div class="notes"><p>The mov instruction simply copies data from source (the operand on the right), to destination (the operand on the left).</p></div></div><div class="step step-level-1" step="38" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="41200" data-y="58000" data-z="0"><h1 id="memory-access-lea">Memory Access - lea</h1><h2 id="id9">Description</h2><p>Calculates an address, but does not actually attempt to access it.</p><h2 id="id10">Basic Use</h2><pre class="highlight code nasm"><span class="c1">; calculate an address by taking the address</span>
<span class="c1">; of what RDX points at,</span>
<span class="c1">; and adding 8 bytes to it (perhaps indexing</span>
<span class="c1">; into an array). Note that we are just calc-</span>
<span class="c1">; ulating the address, NOT accessing memory.</span>
    <span class="nf">lea</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdx</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>     <span class="c1">; actually accessing the memory</span></pre></div><div class="step step-level-1" step="39" data-y="60000" data-rotate-x="90" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="43200" data-z="0"><h1 id="memory-access-xchg">Memory Access - xchg</h1><h2 id="id11">Description</h2><p>Exchanges the values provided atomically (more on this later).</p><h2 id="id12">Basic Use</h2><pre class="highlight code nasm"><span class="nf">xchg</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">rcx</span>   <span class="c1">; exchange two register values</span>
<span class="c1">; exchange a register value with a value stored in memory</span>
<span class="nf">xchg</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">]</span></pre></div><div class="step step-level-1" step="40" data-rotate-y="180" data-rotate-x="90" data-rotate-z="90" data-scale="1" data-x="45200" data-y="62000" data-z="0"><h1 id="lab-1">Lab 1</h1><p>Memory Access</p><ul><li>Copy the Lab1 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab1 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab1 $ ./lab1</pre></div><div class="step step-level-1" step="41" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="47200" data-y="64000" data-z="0"><h1 id="assembly-and-data-types">Assembly and Data Types</h1><ul><li><dl><dt>Slightly different concept than in higher level languages</dt><dd><ul><li>Typically just bytes in a buffer</li><li>Data 'type' is really just interpretation</li><li>Generally differentiated by sizes, alignment, and certain bits being set</li></ul></dd></dl></li><li>Some operations will preserve special properties in a given data set (such as sign, e.g., +/-)</li><li>Other operations may expect different alignments in the data they work on, or may have issues with certain values (such as floating point)</li></ul></div><div class="step step-level-1" step="42" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="49200" data-y="66000" data-z="0"><h1 id="x86-64-general-data-sizes">x86(_64) general data sizes</h1><ul><li>byte - "smallest" addressable unit</li><li>word - two bytes</li><li>dword - double word (4 bytes - pointer width on x86)</li><li>qword - quad word (8 bytes - pointer width on x64)</li></ul></div><div class="step step-level-1" step="43" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="51200" data-y="68000" data-z="0"><h1 id="gdb-examining-memory">GDB: Examining Memory</h1><ul><li>We can use GDB to examing various places in memory with "x" (for "eXamine")</li><li><dl><dt>x has several options:</dt><dd><ul><li>x/nfu - where n is the Number of things to examine, f is the Format, and u is the Unit size</li><li>x addr</li><li>x $&lt;register&gt; - examines the memory address pointed to by the register</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="44" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="53200" data-y="70000" data-z="0"><h1 id="gdb-formatting">GDB Formatting</h1><ul><li>The "f" in x/nfu</li><li><dl><dt>Format options include:</dt><dd><ul><li>s - For a NULL-terminated string</li><li>i - For a machine instruction</li><li>x - For hexidecimal (the default, which changes when x is used)</li></ul></dd></dl></li><li>Example: Disassembling at RIP</li></ul><pre class="highlight code bash"><span class="o">(</span>gdb<span class="o">)</span> x/i <span class="nv">$rip</span></pre></div><div class="step step-level-1" step="45" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="55200" data-y="72000" data-z="0"><h1 id="gdb-unit-sizes">GDB Unit Sizes</h1><ul><li>The "u" in x/nfu</li><li><dl><dt>Unit size options are a bit confusing in the context of x86(_64) assembly, and include:</dt><dd><ul><li>b - bytes</li><li>h - Halfwords (equivalent to "word" in x86(_64) asm; e.g., 2 bytes)</li><li>w - Words (4 bytes, equivalent to dwords)</li><li>g - Giant words (8 bytes, equivalent to qwords)</li></ul></dd></dl></li></ul><div class="notes"><p>Demo - Dumping memory via GDB</p></div></div><div class="step step-level-1" step="46" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="57200" data-y="74000" data-z="0"><h1 id="sub-registers">Sub Registers</h1><img src="images/section_1_register_table.jpg"></img><ul><li>Subregisters are still part of the bigger "parent" register</li><li>Unless special instructions (not yet mentioned) are used, will NOT modify data in the other portions of the register.</li></ul></div><div class="step step-level-1" step="47" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="59200" data-y="76000" data-z="0"><h1 id="memory-register-access-mov">Memory/Register Access - mov</h1><ul><li>When accessing memory, amount of data to copy can be specified</li></ul><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="kt">byte</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">]</span> <span class="c1">; copy a single byte</span>
<span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="kt">dword</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">]</span> <span class="c1">; copy a dword (4 bytes)</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">qword</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">]</span> <span class="c1">; copy a qword (8 bytes)</span></pre><ul><li>Also, data can be copied from subregister to subregister</li></ul><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="nb">cl</span>  <span class="c1">; copy from cl to al</span>
<span class="nf">xchg</span> <span class="nb">al</span><span class="p">,</span> <span class="nb">ah</span> <span class="c1">; exchange the low and high bytes in ax</span></pre></div><div class="step step-level-1" step="48" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="61200" data-y="78000" data-z="0"><h1 id="register-access-movzx">Register Access - movzx</h1><h2 id="id13">Description</h2><p>Move with zero extend. When moving data that is smaller than the destination size,
zero out the remaining bits.</p><h2 id="id14">Basic Use</h2><pre class="highlight code nasm"><span class="nf">movzx</span> <span class="nb">rax</span><span class="p">,</span> <span class="nb">cl</span> <span class="c1">; everything above al is now set to 0</span>
<span class="nf">movzx</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">byte</span> <span class="p">[</span><span class="nb">rsi</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]</span></pre></div><div class="step step-level-1" step="49" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="63200" data-y="80000" data-z="0"><h1 id="lab-2">Lab 2</h1><p>Using subregisters, accessing smaller values, and zero extending.</p><ul><li>Copy the Lab2 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab2 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab2 $ ./lab2</pre></div><div class="step step-level-1" step="50" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="65200" data-y="82000" data-z="0"><h1 id="structures">Structures</h1><ul><li>NASM provides a data structure concept for convenience in handling complex data types</li><li>More of a macro than something truly representative of C-style structs</li><li>Very useful for keeping track of local variables or parameters (among other things)</li></ul></div><div class="step step-level-1" step="51" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="67200" data-y="84000" data-z="0"><h1 id="id15">Structures</h1><pre class="highlight code nasm"><span class="k">struc</span> <span class="nv">MyStruct</span>
        <span class="nf">.field1</span>         <span class="nv">resd</span> <span class="mi">1</span>  <span class="c1">; field1's size is 1 dword</span>
        <span class="nf">.field2</span>         <span class="nv">resd</span> <span class="mi">1</span>  <span class="c1">; field2's size is 1 dword</span>
        <span class="nf">.field3</span>         <span class="nv">resq</span> <span class="mi">1</span>  <span class="c1">; field3's size is 1 qword</span>
<span class="k">endstruc</span>

<span class="c1">; ...</span>
<span class="c1">; This will be equivalent to: mov rax, [rdi+8]</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdi</span> <span class="o">+</span> <span class="nv">MyStruct.field3</span><span class="p">]</span></pre></div><div class="step step-level-1" step="52" data-rotate-x="90" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="69200" data-y="86000" data-z="0"><h1 id="section-review">Section Review</h1><ul><li>Byte Ordering</li><li>Process Layout</li><li><dl><dt>Registers</dt><dd><ul><li>Stack Pointer</li><li>Base Pointer</li><li>Instruction Pointer</li></ul></dd></dl></li><li>Dereferencing Pointers via Register</li><li>Sub registers</li></ul></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>