<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Assembly</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="hardware-overview">Hardware Overview</h1></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Understand the different privilege modes of operation, and some of their implications</li><li>Understand basic memory segmentation and some descriptor tables</li><li>Understand, at a basic level, virtual memory</li><li>Understand basic processor features, control registers, and how they fit together</li><li>Understand and implement Model Specific Registers  (MSRs)</li><li>Utilize x86(_64) instructions to identify the current processor, and understand how to programmatically query its capabilities</li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="processor-modes">Processor Modes</h1></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="user-and-kernel-modes">User and Kernel modes</h1><ul><li>x86(_64) defines several modes of operation (or "rings") the processor can work in</li><li>Each mode has various instructions (and portions of memory) it is allowed to perform</li><li>User mode (which is least privileged) is Ring 3 (which is where most of your applications reside)</li><li>Kernel mode (most privileged) is Ring 0, which is where the core (or kernel) of the OS resides</li><li>Rings 1 and 2 are (largely) unused by most operatings systems</li></ul></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="user-mode">User Mode</h1><ul><li>Mode of least privilege (Ring 3)</li><li>Cannot touch more privileged memory sections</li><li>Cannot execute "privileged" instructions</li><li>Typically must task some facility in the kernel in order to get resources</li></ul></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="kernel-mode">Kernel Mode</h1><ul><li>Mode of most privilege (Ring 0)</li><li>Can access any portion of memory (and change protection)</li><li>Can perform privileged instructions</li><li>Device drivers often run here (in addition to the core portions of the OS)</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><img src="./images/ring_levels.svg"></img></div><div class="step step-level-1" step="7" data-x="9600" data-y="2000" data-rotate-z="90" data-rotate-x="0" data-rotate-y="0" data-scale="1" data-z="0"><h1 id="interrupts-and-memory-segmentation">Interrupts and Memory Segmentation</h1></div><div class="step step-level-1" step="8" data-x="9600" data-y="4000" data-z="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1"><h1 id="tables-and-memory-segmentation">Tables and Memory Segmentation</h1><ul><li><dl><dt>Intel Specifies a number of tables, populated by the OS, which map functionality to the processor.</dt><dd><ul><li>The Interrupt Descriptor Table, or IDT</li><li>The Global Descriptor Table, or GDT</li><li>The Local Descriptor Table, or LDT</li></ul></dd></dl></li><li>Virtual memory also relies on a set of page tables</li></ul></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="9600" data-y="6000" data-z="0"><h1 id="interrupts-and-the-interrupt-descriptor-table">Interrupts and The Interrupt Descriptor Table</h1></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="9600" data-y="8000" data-z="0"><h1 id="interrupts">Interrupts</h1><ul><li><dl><dt>What are interrupts?</dt><dd><ul><li>Interrupts provide a special mechanism to alert the kernel of an event</li><li>Some (though not all) can be temporarily disabled</li><li>Specified via the IDT</li></ul></dd></dl></li><li><dl><dt>Interrupts can be generated many ways:</dt><dd><ul><li>Via hardware events (e.g., a keypress on a keyboard)</li><li>Page or segmentation faults</li><li>Software interrupts also exist</li><li>Many others</li></ul></dd></dl></li></ul><div class="notes"><p>We won't spend too much time on this particular topic (as it only loosely relates to segmentation), but it is important to understand how interrupts work (at a low level), and this will give you the foundational knowledge needed to understand what's happening under the hood later on.</p></div></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="9600" data-y="10000" data-z="0"><h1 id="interrupts-cont-d">Interrupts (Cont'd)</h1><ul><li><dl><dt>Interrupt Service Routines (ISRs)</dt><dd><ul><li>Functions that respond to interrupts</li><li>Set via Interrupt Gates in the IDT (See below)</li></ul></dd></dl></li><li><dl><dt>Interrupt Gates</dt><dd><ul><li>Essentially the entry number (in the IDT) of the ISR you want to call</li><li>The 'int' assembly instruction will call the corresponding ISR</li><li>The 'iret' instruction is provided (on the kernel side) to return back to user mode</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="90" data-scale="1" data-x="9600" data-y="12000" data-z="0"><h1 id="interrupts-example">Interrupts - Example:</h1><p>The following code will perform an exit(0) on Linux (x86):</p><pre class="highlight code nasm"><span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">0x01</span>   <span class="c1">; the system call number</span>
<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="mh">0x00</span>   <span class="c1">; first parameter</span>
<span class="nf">int</span> <span class="mh">0x80</span>                <span class="c1">; interrupt</span></pre></div><div class="step step-level-1" step="13" data-x="9600" data-rotate-y="90" data-z="0" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-y="14000"><h1 id="segment-registers">Segment Registers</h1><ul><li><dl><dt>Segment registers are a special type of register not covered yet, which come in a variety of flavors</dt><dd><ul><li>Each of them can be mapped to provide a special "view" of a section of memory</li><li>Most modern operating systems use a "flat" memory model, forgoing segmentation (almost) entirely</li><li>Still have some real world applications, particularly in Windows</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="90" data-rotate-z="90" data-scale="1" data-x="9600" data-y="16000" data-z="0"><h1 id="id1">Segment Registers</h1><ul><li><dl><dt>The Basics:</dt><dd><ul><li>CS - Code Segment</li><li>DS - Data Segment</li><li>SS - Stack Segment</li><li>FS - Far Segment</li><li>GS - Global Segment</li></ul></dd></dl></li><li>Example: Getting a value from some offset into a segment</li></ul><pre class="highlight code nasm"><span class="c1">; Retrieves the value stored at offset</span>
<span class="c1">; 0x33 into the Global Segment</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nb">gs</span><span class="p">:</span><span class="mh">0x33</span><span class="p">]</span></pre></div><div class="step step-level-1" step="15" data-x="9600" data-rotate-y="180" data-z="1000" data-rotate-x="0" data-rotate-z="90" data-scale="1" data-y="18000"><h1 id="segmentation-segments">Segmentation - Segments</h1><ul><li><dl><dt>What is a segment?</dt><dd><ul><li>Describes a logical section of memory</li><li>Specifies who can access it (e.g., what privilege level you need)</li><li>Indicates the range (start address and length)</li></ul></dd></dl></li><li><dl><dt>Why are they important?</dt><dd><ul><li>Part of the segmentation model, used to map a flat section of memory to the segment registers</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="16" data-x="9600" data-y="20000" data-z="1000" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1"><h1 id="segmentation">Segmentation</h1><p>The Global Descriptor Table (GDT)</p><ul><li>Initialized by the operating system</li><li>Contains various segment descriptors in its entries</li><li>The GDT Register (GDTR) indicates where it is located</li><li>Contains information about how the memory in your system gets mapped</li><li>Also (partially) defines how the transition from user to kernel mode occurs</li><li>Intended to be a global structure</li></ul></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="22000" data-z="1000"><h1 id="id2">Segmentation</h1><p>The Local Descriptor Table (LDT)</p><ul><li>Similar to the GDT</li><li>Intended to have smaller scope: e.g., a per-process construct</li></ul></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="24000" data-z="1000"><h1 id="segmentation-real-world-examples">Segmentation - Real World examples</h1><ul><li>Microsoft uses segmentation to provide fast access to key data structures</li><li><dl><dt>The Thread Environment Block (TEB) in user mode</dt><dd><ul><li>Hangs off of the FS register in x86/GS in x64</li><li>Provides lots of important per-thread information</li></ul></dd></dl></li><li><dl><dt>The Processor Control Block (or KPRCB) in kernel mode</dt><dd><ul><li>Hangs off of the FS register in x86/GS in x64</li><li>Provides lots of important per-processor information</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="26000" data-z="1000"><h1 id="id3">Segmentation</h1><p>Further Reading (if interested):</p><ul><li>The OSDev Wiki describes GDT initialization - <a href="http://wiki.osdev.org/GDT_Tutorial">http://wiki.osdev.org/GDT_Tutorial</a></li><li>The Segment Descriptor Cache - Mr. Robert Collins (from a Dr. Dobbs article) - <a href="http://www.rcollins.org/ddj/Aug98/Aug98.html">http://www.rcollins.org/ddj/Aug98/Aug98.html</a></li></ul></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="28000" data-z="1000"><h1 id="other-processor-features">Other Processor Features</h1></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="30000" data-z="1000"><h1 id="processor-security-features">Processor Security Features</h1><ul><li>DEP/NX</li><li>SMEP/SMAP</li><li>Page Protection</li><li>Write Protection</li></ul></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="32000" data-z="1000"><h1 id="control-registers">Control Registers</h1><ul><li>Control CPU enforcement of a variety of features</li><li>Most security features are enabled in this fashion</li><li>Requires privileged execution (Ring0) to access</li><li>Other features (such as hardware virtualization) also enabled in this fashion</li><li>Feature mappings detailed in the Intel manuals</li></ul></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="34000" data-z="1000"><h1 id="virtual-memory">Virtual Memory</h1><ul><li>Allows a virtual abstraction of hardware addresses</li><li>Paging enabled via CR1</li><li>Page Table location stored in CR3</li><li>Tables and Directories provide fast lookup of address translations</li></ul></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="36000" data-z="1000"><h1 id="page-tables-and-directories">Page Tables and Directories</h1><img src="./images/page_tables2.png"></img><p>Image Credit: <a href="https://notes.shichao.io/utlk/ch2/">https://notes.shichao.io/utlk/ch2/</a></p></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="38000" data-z="1000"><h1 id="model-specific-registers-msrs">Model Specific Registers (MSRs)</h1><ul><li>Many of these exist for x86(_64)</li><li>Most only accessible in privileged mode</li><li>used (sometimes) via RDMSR and WRMSR</li><li>Others have special instructions</li><li>Mainly documented by vendor (e.g., Intel manual)</li></ul></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="40000" data-z="1000"><h1 id="time-stamp-counter">Time Stamp Counter</h1><ul><li>Can read from user mode (via rdtsc)</li><li>Can only modify from kernel mode</li><li><dl><dt>Low bits of result are stored into EAX/high bits in EDX</dt><dd><ul><li>This is the same on both x86 and x86_x64</li><li>x64 - rdtsc will clear the high bits of storage registers</li><li>Results can be combined on x64 to full width with a left-shift and a bitwise or</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="42000" data-z="1000"><h1 id="feature-support">Feature Support</h1><ul><li><dl><dt>The CPUID instruction can provide information about the current CPU</dt><dd><ul><li>Vendor string</li><li>Model number</li><li>Size of internal cache</li><li>Various features supported</li></ul></dd></dl></li><li>The instruction behaves similarly on BOTH x86 and x86_64</li></ul></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="44000" data-z="1000"><h1 id="feature-support-cont-d">Feature Support (Cont'd)</h1><ul><li><dl><dt>The value in EAX at the time of the CPUID call determines what information comes back</dt><dd><ul><li>0 -&gt; Vender ID String - stored in EBX/EDX/ECX</li><li>1 -&gt; Returns a bitfield containing supported features</li><li>...</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="46000" data-z="1000"><h1 id="lab-10">Lab 10</h1><p>MSRs and CPUID</p><ul><li>Copy the Lab10 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab10 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab10 $ ./lab10</pre></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="180" data-rotate-z="90" data-scale="1" data-x="9600" data-y="48000" data-z="1000"><h1 id="section-review">Section Review</h1><ul><li>Ring 0/3</li><li>Interrupts</li><li><dl><dt>Memory Segmentation</dt><dd><ul><li>GDT</li><li>LDT</li></ul></dd></dl></li><li>MSRs</li></ul></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>