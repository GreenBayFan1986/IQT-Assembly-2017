<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Assembly</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="section-2">Section 2</h1><p>Practical Application</p></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="utility-methods">Utility Methods</h1></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Implement a number of basic standard library functions in assembly</li><li>Implement some essential data structures in assembly</li><li>(OPTIONAL) Complete provided bonus labs</li></ul></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><p>Assembly: A Practical Application</p><div class="notes"><p>This section of the course will be mostly hands-on, with relatively short sections of lecture, followed
by larger blocks of labs. The labs have (mostly) been staged so that there are a set of easier exercises,
followed by a section of bonus material. If you complete any of the labs early, the bonus material is
provided for you to work on. Most of the bonus sections have a C implementation provided for reference.</p></div></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="utility-functions">Utility Functions</h1><ul><li><dl><dt>Copy and search functions (Some methods from previous labs, such as the string instruction lab, may be helpful here)</dt><dd><ul><li>strlen</li><li>memcpy</li><li>memset</li><li>memchr</li><li>memcmp</li><li>strchr</li><li>strcmp</li><li>strcpy</li><li>strstr</li></ul></dd></dl></li><li><dl><dt>Conversion</dt><dd><ul><li>atoi</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><p>atoi</p><pre class="highlight code C"><span class="kt">int</span> <span class="nf">atoi</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">accum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// We will start from the 1's place
</span>        <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="o">--</span><span class="n">len</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// subtract 0x30 (the difference
</span>                <span class="c1">// between the number and its
</span>                <span class="c1">// ordinal value as an ASCII character),
</span>                <span class="c1">// multiply by the step,
</span>                <span class="c1">// and add.
</span>                <span class="n">accum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">-</span> <span class="mh">0x30</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span><span class="p">;</span>
                <span class="o">--</span><span class="n">len</span><span class="p">;</span>
                <span class="c1">// Move up by a factor of 10.
</span>                <span class="c1">// First: 1's place, then 10's, etc.
</span>                <span class="n">step</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">accum</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="sorting-bonus-labs">Sorting (Bonus Labs)</h1><ul><li>Insertion Sort</li><li>Quicksort</li></ul></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="lab-13-utility-functions">Lab 13 - Utility Functions</h1></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="system-calls-an-introduction">System Calls - an Introduction</h1></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="id1">Objectives</h1><ul><li>Understand the basic function and implementation of system calls (including legacy methods)</li><li>Understand the basic functionality provided by a C Runtime</li><li>Implement a system call wrapper in assembly</li><li>Begin work on a C Runtime</li></ul></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="system-calls">System Calls</h1><ul><li>Mechanism by which we task the operating system (kernel) to do work</li><li>Implemented by a number of mechanisms, depending on OS/architecture</li></ul></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="system-calls-cont-d">System Calls - Cont'd</h1><ul><li><dl><dt>Many operations require additional privilege to perform</dt><dd><ul><li>File I/O</li><li>Memory allocation</li><li>Process creation</li><li>Device I/O</li><li>...</li></ul></dd></dl></li><li>This requires kernel intervention to occur</li></ul></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="id2">System Calls - Cont'd</h1><img src="./images/section_5_syscall.png"></img></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="legacy-system-call-method">Legacy System Call Method</h1><ul><li>int 0x80/0x2e</li></ul></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="modern-alternative">Modern Alternative</h1><ul><li>x86: sysenter / sysexit</li><li>x64: syscall</li></ul></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="my-first-syscall">My First Syscall</h1><p>Wrapping system calls</p><ul><li>x86</li><li>x64</li></ul></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="getting-information">Getting Information</h1><ul><li>Man pages often have a comprehensive list of required flags (even if definitions are buried in header files)</li><li>May be more than 1 section to a man page (if the page overlaps with a utility page "2" generally has dev docs)</li></ul><pre class="highlight code bash">~$ man mmap
~$ man <span class="m">2</span> open</pre></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="c-runtimes-a-good-start">C Runtimes: A good _start</h1><ul><li>What is a runtime?</li><li>int main() vs your program's real entry point</li><li>Building without a standard library</li><li>stuff your crt usually does</li></ul></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="compiling-with-no-crt">Compiling with no CRT</h1><ul><li>All functions will need to implemented/provided</li><li><dl><dt>Initial effort: Wrap system functionality</dt><dd><ul><li>sys_exit</li><li>write</li></ul></dd></dl></li></ul></div><div class="step step-level-1 split-table" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="sys-exit">sys_exit</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>RAX</p></td><td><p>RDI</p></td></tr><tr><td><p>60</p></td><td><p>status (int)</p></td></tr></tbody></table></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="implementing-sys-exit">Implementing sys_exit</h1><pre class="highlight code nasm">    <span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">60</span>  <span class="c1">; the syscall number (in this case exit)</span>
    <span class="nf">xor</span> <span class="nb">rdi</span><span class="p">,</span> <span class="nb">rdi</span> <span class="c1">; argument 1, the exit code</span>
<span class="nf">syscall</span>
    <span class="nf">ret</span></pre></div><div class="step step-level-1 split-table" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="some-setup">Some Setup</h1><ul><li>STDOUT - A special kind of file descriptor (1)</li><li>sys_write</li></ul><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>RAX</p></td><td><p>RDI</p></td><td><p>RSI</p></td><td><p>RDX</p></td></tr><tr><td><p>1</p></td><td><p>fd</p></td><td><p>buffer ptr</p></td><td><p>Count</p></td></tr></tbody></table></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="lab-14">Lab 14</h1><p>Finally, time for "Hello, World!"</p><h2 id="required-objectives">Required Objectives:</h2><p>Populate _start, and perform the following actions:</p><ul><li>Wrap sys_write</li><li>Wrap sys_exit</li><li>Print the string "Hello, World!" to STDOUT</li><li>Exit without seg fault</li></ul></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="allocation">Allocation</h1></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="id3">Objectives</h1><ul><li>Understand the basic roles and responsibilities of a simple allocator</li><li>Understand the function of the mmap syscall</li><li>Implement a simple allocator</li></ul></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="allocating-memory">Allocating Memory</h1><ul><li><dl><dt>The Heap - no longer just a call to malloc</dt><dd><ul><li>In this case, malloc does not exist!</li></ul></dd></dl></li><li>How do we add memory to our process?</li></ul></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="about-allocators">About Allocators</h1><ul><li><dl><dt>Many different strategies for heap management</dt><dd><ul><li>Lots of special cases to consider</li><li>Multithreading adds more concerns (we'll talk more about this later)</li></ul></dd></dl></li><li>Our strategy here will try to remain simple</li></ul></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="our-allocator-strategy">Our Allocator Strategy</h1><ul><li>Getting new memory from the kernel every time we need to allocate is very inefficient</li><li>We'll want to build a list of unused (or "free") chunks to hand out when allocations are requested</li><li>When a chunk is requested, we can check the free list first (if initialized), to see if we have something that will work</li><li>If not, we'll need to allocate memory</li></ul></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="asking-for-more">Asking for More</h1><ul><li><dl><dt>We can actually ask for memory from the kernel in two ways:</dt><dd><ul><li>mmap - This is the more "modern" approach; we can ask the kernel for more memory by requesting an anonymous page mapping (we'll be discussing mmap in much greater detail over the next few sections)</li><li>brk - We won't really touch this too much; it lets you extend or shrink the end of the memory mappings in your program</li></ul></dd></dl></li><li>Some additional initialization logic can also be added to _start, if needed</li></ul></div><div class="step step-level-1 split-table" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><h1 id="mmap">mmap</h1><ul><li>Lets us create a memory mapping</li><li>May be backed by a file, or anonymous</li><li>This will be the base for our allocator</li></ul><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>RAX</p></td><td><p>RDI</p></td><td><p>RSI</p></td><td><p>RDX</p></td><td><p>R10</p></td><td><p>R8</p></td><td><p>R9</p></td></tr><tr><td><p>9</p></td><td><p>addr (or NULL)</p></td><td><p>length</p></td><td><p>Protection</p></td><td><p>Flags</p></td><td><p>Descriptor (or NULL)</p></td><td><p>offset</p></td></tr></tbody></table></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="48000" data-y="0" data-z="0"><h1 id="arguments">Arguments</h1><ul><li>Protection (from mman-linux.h)</li></ul><pre class="highlight code nasm"><span class="cp">%define PROT_READ       0x1      </span><span class="c1">; Page can be read.
</span><span class="cp">%define PROT_WRITE      0x2      </span><span class="c1">; Page can be written.
</span><span class="cp">%define PROT_EXEC       0x4      </span><span class="c1">; Page can be executed.
</span><span class="cp">%define PROT_NONE       0x0      </span><span class="c1">; Page can not be accessed.</span></pre><ul><li>Flags (need to be OR'd together)</li></ul><pre class="highlight code nasm"><span class="cp">%define MAP_ANONYMOUS   0x20  </span><span class="c1">; Don't use a file.
; ...</span>
<span class="cp">%define MAP_PRIVATE             0x02  </span><span class="c1">; Changes are private.</span></pre></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="49600" data-y="0" data-z="0"><h1 id="creating-a-heap">Creating a Heap</h1><ul><li>Beginning the Process: malloc and free</li><li><dl><dt>Steps to success</dt><dd><ul><li>Initialization: Handled in _start</li><li>Making Requests: Define a "block" size</li><li>Keeping a list: Maintain a list of "free" chunks</li></ul></dd></dl></li></ul></div><div class="step step-level-1 split-table" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="51200" data-y="0" data-z="0"><h1 id="munmap">munmap</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>RAX</p></td><td><p>RDI</p></td><td><p>RSI</p></td></tr><tr><td><p>11</p></td><td><p>addr</p></td><td><p>length</p></td></tr></tbody></table></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="52800" data-y="0" data-z="0"><h1 id="more-about-memory-mapping">More About Memory Mapping</h1><ul><li><dl><dt>Two types of allocation:</dt><dd><ul><li>File-backed</li><li>Anonymous</li></ul></dd></dl></li><li>Both create an addessable buffer in your process space (assuming success)</li></ul></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="54400" data-y="0" data-z="0"><h1 id="memory-mapping-cont-d">Memory Mapping - Cont'd</h1><img src="./images/section_5_mem_map.png"></img></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="56000" data-y="0" data-z="0"><h1 id="demonstration-mmap">Demonstration - mmap</h1></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="57600" data-y="0" data-z="0"><h1 id="problem-description">Problem Description</h1><p>Some pseudo-C to describe our malloc strategy:</p><p>Some initial structure information:</p><pre class="highlight code c"><span class="cm">/**
* Our free list node structure definition.
* In this case, just a simple linked list.
*/</span>
<span class="k">struct</span> <span class="n">heap_node</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">heap_node</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">heap_node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">heap_node</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">free_list</span> <span class="p">{</span>
        <span class="n">heap_node</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span> <span class="n">free_list</span><span class="p">;</span>

<span class="cm">/* Add structure overhead to our alloc size */</span>
<span class="cp">#define HEAP_ALLOC_SIZE(x)      (sizeof(heap_node) + x)
</span><span class="cm">/* The beginning of our free list; head starts out NULL */</span>
<span class="n">free_list</span> <span class="n">free_start</span><span class="p">;</span></pre></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="59200" data-y="0" data-z="0"><h1 id="id4">Problem Description</h1><pre class="highlight code c"><span class="cm">/* NOTE: n is the allocation size requested */</span>
<span class="n">heap_node</span><span class="o">*</span> <span class="nf">check_free_list</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">heap_node</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">heap_node</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="cm">/*
        * If our list is empty, we need to
        * allocate.
        */</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">free_start</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="n">current</span> <span class="o">=</span> <span class="n">free_start</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* Remove from the list */</span>
                <span class="n">free_start</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span>
                                <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="nl">next</span> <span class="p">:</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">do</span> <span class="p">{</span>
        <span class="cm">/* Walk the list, find and remove a
        * chunk of at least size n
        */</span>
        <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="38" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="60800" data-y="0" data-z="0"><h1 id="id5">Problem Description</h1><pre class="highlight code c"><span class="kt">void</span><span class="o">*</span> <span class="nf">allocate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">heap_node</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">alloc_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/*
        * We'll check the free list first,
        * and see if there is a suitable chunk
        */</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">check_free_list</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="p">{</span>
                <span class="cm">/* We found a match! */</span>
                <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/*
        * Since we need to allocate, we have
        * to add enough to our header to
        * account for our heap_node struct!
        */</span>
        <span class="n">alloc_size</span> <span class="o">=</span> <span class="n">HEAP_ALLOC_SIZE</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="cm">/* We'll allocate some space */</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">mmap_anon_page</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">)))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="cm">/* Return the beginning of the data buffer */</span>
        <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="39" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="62400" data-y="0" data-z="0"><h1 id="id6">Problem Description</h1><pre class="highlight code c"><span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">heap_node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="cm">/*
        * Subtract the size of the bookkeeping struct to get
        * back to the top of the heap_node structure in
        * memory
        */</span>
        <span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">heap_node</span><span class="o">*</span><span class="p">)(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">heap_node</span><span class="p">));</span>
        <span class="cm">/* Zero the user provided data */</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
        <span class="cm">/* Add the node to the free list */</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">free_start</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
        <span class="n">free_start</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span></pre></div><div class="step step-level-1" step="40" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="64000" data-y="0" data-z="0"><h1 id="additional-steps-to-consider">Additional Steps to Consider</h1><ul><li>Keep track of the number of items on the free list; release some if it becomes too large</li><li>Keep multiple free lists based on chunk size</li></ul></div><div class="step step-level-1" step="41" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="65600" data-y="0" data-z="0"><h1 id="lab-creating-an-allocator">Lab - Creating an Allocator</h1><p>Implement Dynamic Allocation</p><h2 id="id7">Required Objectives:</h2><ul><li><dl><dt>Implement "allocate" so that it can:</dt><dd><ul><li>Check a list of "free" chunks for an already-allocated block</li><li>If a suitable block exists, remove it from the list and return it for use</li><li>If no suitable block exists, use mmap to get one</li></ul></dd></dl></li><li><dl><dt>Implement "deallocate" so that it can:</dt><dd><ul><li>Return "free" block to the free list</li><li>(optionally) De-allocate blocks if the free list is too large</li></ul></dd></dl></li><li><dl><dt>Additionally:</dt><dd><ul><li>You will need to keep track of how big the allocated block is somehow</li></ul></dd></dl></li></ul></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>